# -*- coding: utf-8 -*-
"""Polynomial_Reagression.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11sdNZ6nrDGyQy7D-b_Adq9VhUCGEMT4a
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import collections

data = pd.read_csv('/content/tracks.csv')                               # read the data
# data.head()

data['duration_min'] = (data['duration_ms'])/1000/60                    # convert time units
data.drop(['duration_ms'], axis=1, inplace = True)                      # drop duration_ms

freq = collections.Counter(data['artists'])                             # calculate frequencies
top_99 = sorted(freq.items(), key=lambda x: x[1], reverse=True)[:100]
for i in range(99):
  top_99[i] = top_99[i][0]
print(top_99)
artists = data['artists']


## segment data into input and output
X = data[['duration_min', 'explicit', 'release_date', 'danceability', 'energy', 'key', 'loudness', 'mode', 'speechiness', 'acousticness', 'instrumentalness', 'liveness', 'valence', 'tempo', 'time_signature']]
Y = data['popularity']
# X

import seaborn as sns
cr = data.corr()                                # calculate correlation matrix
plt.figure(figsize=(20, 12))
sns.heatmap(cr, annot=True)                     # plot heatmap

X, y = X.to_numpy(), Y.to_numpy()               # convert to numpy
_X, _y, _artists = [], [], []
for i in range(X.shape[0]):
  flag = True
  for j in range(X.shape[1]):
    if X[i][j] != X[i][j]:
      flag = False
  if flag:
    _X.append(X[i])
    _y.append(Y[i])
    _artists.append(artists[i])
for i in range(len(_X)):                              # datatype conversion
  _X[i][2] = int (str (_X[i][2])[:4])

X, y = np.array(_X), np.array(_y)
artist = np.array(_artists)                           # to numpy
print(X.shape)

# print(X.shape)
for i in range(99):
  lst = []
  for j in range(X.shape[0]):
    lst.append([1 if artists[2] == top_99[i] else 0])
  X = np.append(X, lst, axis=1)
lst = []
for i in range(X.shape[0]):
  lst.append([1 if artists[2] not in top_99 else 0])
X = np.append(X, lst, axis=1)

# for j in range(X.shape[1]):
#   mean, mx, mn = 0, -1e9, 1e9
#   for i in range(X.shape[0]):
#     mean += X[i][j]/X.shape[0]
#     mx = max(mx, X[i][j])
#     mn = min(mn, X[i][j])
#   for i in range(X.shape[0]):
#     X[i][j] = (X[i][j]-mean)/(mx-mn)
# print(X.shape)

from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)

from sklearn import linear_model
from sklearn.model_selection import GridSearchCV

lasso_reg = linear_model.Lasso(alpha=1e-3)                      # Lasso model
lasso_reg.fit(X_train, y_train)                                 # fit the model
print(X_train.shape)
print(lasso_reg.coef_)

def get_loss(X_train, y_train, X_test, y_test, alpha):          # loss calculation - Mean Squared error
  lasso_reg = linear_model.Lasso(alpha=alpha)
  lasso_reg.fit(X_train, y_train)
  return (1/X_test.shape[0])*np.sum(np.square(lasso_reg.predict(X_test) - y_test))

def k_fold_cv(k: int, X: np.ndarray, y: np.ndarray, alpha: float):
  '''
    This method performs K-fold cross validation on the input samples with labels.
    Parameters:
      k (int): Value of K
      X (numpy array): samples
      y (numpy array): expected output/labels
      alpha (float): value of alpha in K-fold cross validation

  '''
  loss = 0
  for i in range(k):
    X_test, X_train, y_test, y_train = [], [], [], []
    for j in range(len(X)):
      if j >= i*k and j < (i+1)*k:
        X_test.append(X[j])
        y_test.append(Y[j])
      else:
        X_train.append(X[j])
        y_train.append(Y[j])
    X_train, X_test, y_train, y_test = np.array(X_train), np.array(X_test), np.array(y_train), np.array(y_test)
    loss += get_loss(X_train, y_train, X_test, y_test, alpha)
  return loss / k

rng = np.arange(1e-3, 1, 5e-3)
loss_list = []
for alpha in rng:                                         # calculate loss for different alpha
  loss_list.append(k_fold_cv(10, X, y, alpha))
plt.plot(rng, loss_list)
plt.show()

